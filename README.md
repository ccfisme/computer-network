1.1</br>
没讲啥，就明白了因特网就是互联网这个概念，对Internet的翻译不同而已</br></br>
1.2</br>
先讲的互连网，也就是多个计算机通过路由器连在一起，最初美国发明的是一根线，这根线叫ARPANET，后来用的地方多了，就用一些类似路由器的设备把多个计算机连成一片，这也就是第一个互连网，再后来1983规定了一个TCP/IP协议，只要遵守就可以互相连接，这就是互联网的诞生</br>
后来发现要想使连接到互联网的所有用户都可以相互通信，单靠线线连接并不可行，如聊城与北京相隔486公里，如果传输一个大型文件，那么一个一个节点一个节点的传，势必会造成堵塞和效率低下，所以可以建一个更大的市级的节点，然后让市与市之间连接，这其实已经解决绝大部份的问题了，不过考虑到更远的比如云南到哈尔滨，这就需要更大的节点，即联通整个国家的节点，这也就是三级ISP结构，(ISP是指交换的节点，其中市级与市级之间可通过IXP直接交换信息)即
![IMG_20210919_154812](https://user-images.githubusercontent.com/74129445/133919723-9676fb3e-13d5-4c52-af4e-6d9ae5b519e2.jpg)</br>
然后简单介绍了万维网，它代表web网页的出现</br></br>
1.3</br>
以工作方式的不同介绍了互联网两个结构</br>
一个是边缘部分，即连接在互联网的所有主机，小的叫个人电脑，大的叫服务器。这些主机之间的通信方式又分为两类。一类是“客户端-服务器”方式，也就是我之前学的Java web，即主机A运行客户端程序，发出请求，主机B运行服务器程序，接收请求作出响应。另一类是“对等连接”方式，即不区分哪个是服务请求方，哪个是服务提供方，只要有对等连接软件P2P，就可以既做服务器，又做客户端，并且这一类可以支持大量对等用户</br>
另一个是核心部分，也就是如何实现的数据传输。就比如两个电话发生信息交互，则需要两根线，一根输入数据，一根输出数据，如果是10000个电话相连接，那么线实在是太多了，所以发明了交换机，即
![截屏2021-09-19 16 24 46](https://user-images.githubusercontent.com/74129445/133920715-bcd8a42c-0f03-40f1-a047-20cf24ea9ca0.png)</br>
不过要想把这种模式转移到计算机方面，就太浪费了，因为在通话的时间内通话的两个用户始终占线，如果我在线编辑一个云保存的文档，岂不是一直都要占用这条线路，实在是浪费，并且计算机的数据都是突发式的出现在传输线路上的，所以后面出现了存储转发技术，即
![截屏2021-09-19 16 50 10](https://user-images.githubusercontent.com/74129445/133921360-80f52be9-64b1-432d-8acb-99718a062418.png)</br>
这里我出现了一个疑问，服务器与路由器的区别有什么？明明都是传输数据的，后来发现这个问题很愚蠢，服务器是存储数据，按请求发送数据，路由器是转发数据，根本是两个东西</br></br>
1.4</br>
计算机在中国怎么发展的，没啥意思，过</br></br>
1.5</br>
先讲了计算机网络的定义，就是由可编程硬件（即一定包含CPU）互连而成，这也就是说互联网是最大的计算机网络</br>
又讲了几个网络作用范围的的划分</br>
广域网WAN--跨越国家</br>
城域网MAN--跨越城市</br>
局域网LAN--跨越学校企业</br>
个人区域网PAN--10m以内，也叫WPAN</br>
这里我有了疑问，什么是个人区域网？与WLAN有什么区别？Wi-Fi又是什么？</br>
参考：http://blog.sina.com.cn/s/blog_63f3ca740100go7x.html</br>
https://www.google.com/search?q=WLAN%E4%B8%8EWI-FI%E5%8C%BA%E5%88%AB&oq=WLAN%E4%B8%8EWI-FI%E5%8C%BA%E5%88%AB&aqs=chrome..69i57.7707j0j4&sourceid=chrome&ie=UTF-8</br>
也就是说，WLAN与WPAN用法差不多，但是更为廉价和高效，而WI-FI是WLAN下的一种技术</br>
最后讲了一个接入网AN，也就是主机连到本地ISP的第一个路由器（边缘路由器），既不属于边缘部分，也不属于核心部分，是这两者的桥梁。</br>
1.6</br>
主要讲了计算机网络的性能</br>
介绍了几个定义</br>
数据率（速率）：数据的传输速率 = 数据长度 / 发送时间，单位是bit/s</br>
带宽：最高速率</br>
吞吐量：实际到达目的地的传输速率</br>
时延：数据从网络的一端到另一端的时间，计算方法为 = 发送时延 + 传播时延 + 处理时延 + 排队时延</br>
发送时延：主机或路由器发送数据帧用的时间 = 数据帧长度 / 数据帧发送速率</br>
传播时延：电磁波在网线传输的时间 = 网线长度 / 电磁波在网线的传播速率</br>
处理时延：主机或路由器收到包后分析首部，提取数据，查找转发表</br>
排队时延：包进入路由器确定转发接口后要排队，等前面的传完，要是当时访问的人多，还会有队列溢出，造成排队时延无穷大</br>
时延带宽积：即时延 * 带宽，也就是每秒传播的数据量</br>
往返时间RTT：即RTT = 传播时延 + 处理时延 + 排队时延</br>
有效数据率：也就是有效传播速率 = 数据长度 / （发送时延 + RTT），这与数据率的定义不同</br>
网络空闲率：就像马路上的车每秒空闲车道占总车道多少。网络空闲率 = 网络空闲时延 / 网络现在时延</br>
网络利用率（信道利用率）：就像马路上的车每秒占车道的多少，并且不是越大越好，容易堵塞。网络利用率 = 1 - 网络空闲率</br>
1.7</br>
讲的计算机网络架构</br>
参考：https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</br>
https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</br>
物理层：连接电脑的物理手段</br>
链接层:0、1在物理层传播，但是不知道0、1代表什么，也不知道怎么理解，所以出现了以太网协议来规定0、1分组方式（链接层的功能），即一组电信号构成一个数据包，数据包包含标头和数据，其中标头包含发送者和接受者的信息及数据类型。由于网络信息要通过网卡进入电脑，而每个网卡的地址（MAC）又是独一无二的，所以发送者和接受者的信息其实就是网卡地址，那么如何接收发送方的MAC地址呢？用的是ARP协议，即通过IP解析出MAC地址，这个下面讲。知道对方MAC地址怎么精准发送信息呢？把数据包向网内所有计算机发送，如果是对的MAC地址，就解析。</br>
网络层：以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一"包"，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起堵塞和资源浪费。因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。即如果是同一个子网络，就采用广播方式发送，否则就采用"向不同的子网络分发数据包"的方式发送。遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关，这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</br>
规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。每个电脑都有IP地址，不过需要动态分配,所谓"动态IP地址"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数</br>
DHCP协议</br>
首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：![bg2012061102](https://user-images.githubusercontent.com/74129445/134048747-10a010a4-ac3c-4088-a1a5-72e352bd37d9.png)</br>
（1）最前面的"以太网标头"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。

　　（2）后面的"IP标头"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。

　　（3）最后的"UDP标头"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。

这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。

接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。

新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</br>


IP地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数"子网掩码"（subnet mask）。所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。知道"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</br>
根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？回答是不需要，我们可以把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。具体来说，IP数据包也分为"标头"和"数据"两个部分。标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样</br>
![bg2012052910](https://user-images.githubusercontent.com/74129445/133937554-515f470b-7f54-4bbd-a31c-0e6b3347bc6e.png)</br>
ARP协议：关于"网络层"，还有最后一点需要说明。</br>
因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。
所以，我们需要一种机制，能够从IP地址得到MAC地址。</br>
这里又可以分
成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。
</br>![bg2012061101](https://user-images.githubusercontent.com/74129445/133937909-8563b02f-15e3-4362-a60c-58076d06b5da.jpeg)</br>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</br>


第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</br>
总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</br>
传输层：有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。

接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？

也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

"端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。

"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。</br>
UDP协议：

现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号,结果又多了一个头</br>
![bg2012052912](https://user-images.githubusercontent.com/74129445/133937695-dd8c90cd-cbdb-48b9-8c75-c8ec70b8b012.png)</br>优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</br>
TCP协议：这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。

因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。

TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</br>
应用层：应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。

"应用层"的作用，就是规定应用程序的数据格式。

举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。

这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。因此，现在的以太网的数据包就变成下面这样。
![bg2012052913](https://user-images.githubusercontent.com/74129445/133937793-91004b4f-8b2a-4999-993f-9585cf184539.png)
</br>第一章结束
